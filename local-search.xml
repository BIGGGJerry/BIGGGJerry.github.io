<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java学习</title>
    <link href="/2024/11/17/JAVA%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/11/17/JAVA%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>要了解Android先从Java学起吧</p><span id="more"></span><ol><li><p>JDK开发 JRE运行</p></li><li><p>class java最基本的单元；字符串双引号 字符单引号；一个class文件下只能有一个public class </p></li><li><p>\t 制表符 可用单双号引起来 把String长度补到8x</p></li><li><p>数据类型需要赋值 float 和 long加后缀 标识符区分大小写</p></li><li><p>接收输入 import java.util.Scanner; Scanner sc = new Scanner(System.in); int i = sc.nextInt();</p></li><li><p>project module模块（新建File-&gt;structure） package包 class类（文件名和类名一致）</p></li><li><p>psvm or main， sout可以直接回车</p></li><li><p><strong>字面量literal</strong>：字符单引号 ；0b 0 0x对应二八十六进制</p></li><li><p><strong>标识符</strong>：不能数字开头  变量名方法名小驼峰 类名大驼峰 </p></li><li><p><strong>方法</strong>：</p><blockquote><p>修饰符 返回值类型 方法名（形参列表） {方法代码 return 结果}</p></blockquote></li><li><p><strong>变量</strong>：</p><ol><li><p>成员变量</p><ol><li><p>静态成员变量：全部对象共享</p></li><li><p>实例成员变量：每个对象独有</p></li></ol></li><li><p>局部变量：方法中的变量</p></li></ol><p>基本类型变量：int char etc</p><p>引用类型变量：数组 对象</p></li><li><p>byte short char 在表达式中都自动转换成int运算；</p><p>逻辑运算符 &amp; ｜ ^ ！&amp;&amp; || 后二者可以仅判断左边</p></li></ol><p>​switch不支持double float long</p><p>​静态数组eg String[] name = {} or String[] name = new String[]{} or String name[] = new String[]{}</p><p>​动态数组eg String[] name = new String[9]</p><p>​二维静态数组String[][]={{}}</p><p>​二维动态数组String[][]= new String[3][7]</p><p>​Arrays.toString()可以返回数组内容 然后sout</p><ol start="13"><li><p><strong>类</strong>（对象是类的实例）的基本语法：</p><p>1⃣️构造器or构造方法：</p><blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {<br> <span class="hljs-comment">//构造器无返回值，name和类名相同，可重载；无参构造器自带；有有参构造器则无参构造器默认无 </span><br> String name;<br> <span class="hljs-type">int</span> age;<br> <span class="hljs-type">char</span> gender;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>{<br>     System.out.println(<span class="hljs-string">"this is constructor without parameter"</span>);<br> }<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span>{<br>     System.out.println(<span class="hljs-string">"this is constructor with parameter:"</span>+name);<br> }<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String n,<span class="hljs-type">int</span> a,<span class="hljs-type">char</span> g)</span>{<br>     System.out.println(<span class="hljs-string">"this is constructor with parameter:"</span>+n+a+g);<br>     name = n;<br>     age = a;<br>     gender = g;<br> }<br>}<br><span class="hljs-comment">//可以通过this在一个类中调用兄弟构造器，写在构造器第一行</span><br></code></pre></td></tr></tbody></table></figure></blockquote><p>2⃣️this：</p><blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {<br>    <span class="hljs-comment">//this是一个变量 用于拿到当前对象</span><br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String name)</span>{<span class="hljs-comment">//这里的name是歌名</span><br>        System.out.println(<span class="hljs-built_in">this</span>.name+<span class="hljs-string">"喜欢"</span>+name);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></blockquote><p>3⃣️封装capsulation（面向对象三大特征：封装 多态 继承）：就是权限修饰符private</p><blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {<br>    <span class="hljs-comment">//使用private对变量合理隐藏</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//如何暴露private：使用public修饰的get和set</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {<br>        <span class="hljs-built_in">this</span>.name = name;<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> {<br>        <span class="hljs-built_in">this</span>.age = age;<br>    }<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>{<br>        <span class="hljs-keyword">return</span> name;<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>{<br>        <span class="hljs-keyword">return</span> age;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></blockquote><p>4⃣️实体类Javabean：成员变量全部私有，有get&amp;set，必须有无参构造器</p><p>5⃣️static：</p><p>静态变量（类变量）：被全部的对象共享</p><p>实例变量（对象的变量）：每个对象有自己的</p><p>静态方法：属于类 可用类名.方法名使用；静态方法中只可以有静态变量/方法；静态方法中不可以使用this</p><p>实例方法：属于对象</p><p>工具类：包含一些静态方法，工具类的<strong>构造器</strong>可以直接私有</p><p>6⃣️继承extends：继承非私有成员；子类父类成员名字重复时，在子类访问父类的成员可用super.成员名</p><p>方法重写：方法的名称和参数列表必须一样，前一行加上@override，子类重写的方法访问权限需要大于等于父类，返回值类型要比父类相等或更小，<strong>私有方法</strong>和<strong>静态方法</strong>不能重写</p><p>子类构造器：先调用父类构造器，再调用子类构造器。如果父类有无参构造器，则子类会默认第一行super();；如果父类没有无参构造器，则需要在子类构造器的第一行super(…)（必须写在构造器第一行）调用父类有参构造器。</p><p>7⃣️多态polymorphsm：使用父类类型作为参数，可以接受一切子类对象；多态对象不能调用子类独有功能；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-comment">//1.对象多态</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wolf</span>();<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Totoise</span>();<br>        <span class="hljs-comment">//2.行为（方法）多态，编译看左，运行看右</span><br>        a1.run();<br>        a2.run();<br>        <span class="hljs-comment">//3.使用父类类型作为参数，可以接受一切子类对象</span><br>        go(a1);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">go</span><span class="hljs-params">(Animal animal)</span>{<br>        System.out.println(<span class="hljs-string">"使用父类类型作为参数，可以接受一切子类对象"</span>);<br>        animal.run();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>{<br>        System.out.println(<span class="hljs-string">"this is Animal class"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Totoise</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>{<br>        System.out.println(<span class="hljs-string">"this is Totoise class"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wolf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>{<br>        System.out.println(<span class="hljs-string">"this is Wolf class"</span>);<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>this is Wolf class<br>this is Totoise class<br>使用父类类型作为参数，可以接受一切子类对象<br>this is Wolf class</p></blockquote><p>多态下的类型转换（强转后调用子类独有功能）：强制从父类转化到子类 子类 变量名 = (子类)父类变量 （只能强转为原定义时等号右边的类型）</p><p>强制转换前可以使用intenceof判断（判断原等式右边的类型）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(a1 <span class="hljs-keyword">instanceof</span> Wolf){<br><span class="hljs-type">WoLf</span> <span class="hljs-variable">w1</span> <span class="hljs-operator">=</span> (Wolf) a1;<br>w1.eatsheep();<br>}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a1 <span class="hljs-keyword">instanceof</span> Tortoise){<br><span class="hljs-type">Tortoise</span> <span class="hljs-variable">tl</span> <span class="hljs-operator">=</span> (Tortoise) a1;<br>t1.run()<br>};<br></code></pre></td></tr></tbody></table></figure><p> 8⃣️权限修饰符：private（只能本类）&lt;缺省（本类、同包下的类）&lt;protected（本类、同包下的类、子孙类）&lt;public</p></li><li><p><strong>final关键字</strong>：</p><p>最终类：不可以被继承</p><p>最终方法：不可以被重写</p><p>被修饰变量：仅可以被赋值一次</p><p>final修饰的基本类型变量不可以再次赋值，修饰的引用类型变量的地址是固定的但可以再次赋值。</p><p>static final修饰的为<strong>常量</strong>（命名全大写）</p></li><li><p><strong>单例类</strong>（设计模式是解决问题的方案，单例是其中一种）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br>    <span class="hljs-comment">//1.定义一个静态变量，用于构建本类的唯一对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    <span class="hljs-comment">//2.私有化构造器，确保外部不可创建对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span>{<br>    }<br>    <span class="hljs-comment">//3.提供一个静态方法用来返回唯一的对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>{<br>        <span class="hljs-keyword">return</span> a;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p>枚举类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">A</span>{<br>X,Y,Z;<br>}<br></code></pre></td></tr></tbody></table></figure><p>枚举类的第一行必须是名称，对应对象（对象是public static final的）</p><p>枚举类都是最终类，不可以被继承</p><p>构造器私有，不用写，不可以创建对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>{<br><span class="hljs-comment">// 目标:认识枚举类，搞清楚其本质特点。</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> A.X;<br>System.out.printin(a1);<span class="hljs-comment">//X</span><br><span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> A.Y;<br>System.out.printin(a2);<span class="hljs-comment">//Y</span><br>System.out.println(a1.name());<span class="hljs-comment">//X</span><br>System.out.println(a2.name());<span class="hljs-comment">//Y</span><br>System.out.printin(a1.ordinal());<span class="hljs-comment">//索引0</span><br>System.out.println(a2.ordinal());<span class="hljs-comment">//索列1</span><br>}<br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>抽象类abstract</strong>：抽象类不能建立对象（可以用父类名创建对象），只能作为父类让子类继承</p><p>可以修饰类和成员方法，修饰成员方法<strong>只有方法签名</strong>而没有方法体（不用写大括号但需写分号）</p><p>抽 象类中不一定有抽象方法，但抽象方法必须在抽象类中</p><p>一个类继承抽象类必须重写父类中全部抽象方法</p><p>应用场景：父类知道每一个子类的动作但不知道子类具体要做什么</p><p>模版方法（也是一个设计模式）：适用于父类部分内容需要重写的情况</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>() ;<br>        s1.write();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> {<br>    <span class="hljs-comment">//模版方法设计模式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>{<span class="hljs-comment">//加个final防止被重写 </span><br>        System.out.println(<span class="hljs-string">"这里的内容是不同的身份都一样的 "</span>);<br>        <span class="hljs-comment">//以下 内容是每个子类都写，但是内容不同的；这里父类写一个抽象方法，具体实现交给子类</span><br>        writeMain();<br>        System.out.println(<span class="hljs-string">"这里的内容也是不同的身份都一样的 "</span>);<br>    }<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeMain</span><span class="hljs-params">()</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">People</span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeMain</span><span class="hljs-params">()</span>{<br>        System.out.println(<span class="hljs-string">"这是学生的正文"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">People</span>{<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeMain</span><span class="hljs-params">()</span>{<br>        System.out.println(<span class="hljs-string">"这是老师的正文"</span>);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><blockquote><p>这里的内容是不同的身份都一样的<br>这是学生的正文<br>这里的内容也是不同的身份都一样的  </p></blockquote></li><li><p><strong>接口interface</strong>： 接口不能创建对象 </p><blockquote><p>public interface 接口名{</p><p>​//传统接口JDK8只能写常量和抽象方法</p><p>​//接口中常量不用写public final static</p><p>​//接口中抽象方法不用写public abstract </p><p>​//JDK8之后新增默认方法（default 默认用public修饰，只能用接口的实现类来调用） 私有方法（只能用接口中的其他实例方法来调用） 静态方法（默认public，只能使用接口名调用 ）</p><p> } </p></blockquote><p>接口用来被类实现，实现接口的类叫实现类，一个实现类可以实现多个接口</p><p>作用：可以将接口规定的方法功能给多个类实现 方便切换业务 </p><p><strong>接口与抽象类对比</strong></p><blockquote><p>相同点:</p><p>1、多是抽象形式，都可以有抽象方法，都不能创建对象。<br>2、都是派生子类形式:抽象类是被子类继承使用，接口是被实现类实现。<br>3、一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则自己要成为抽象类或者报错!<br>4、都能支持的多态，都能够实现解耦合。</p><p>不同点:</p><p>1、抽象类中可以定义类的全部普通成员，接口只能定义常量，抽象方法(JDK8新增的三种方式)2、抽象类只能被类单继承，接口可以被类多实现。<br>3、一个类继承抽象类就不能再继承其他类，一个类实现了接口(还可以继承其他类或者实现其他接口)。<br>4、抽象类体现模板思想:更利于做父类，实现代码的复用性。<br>5、接口更适合做功能的解耦合:解耦合性更强更灵活。</p></blockquote></li><li><p>代码块（类中的成分）：</p><p><strong>静态代码块static{}</strong></p><p>特点：只在最初执行一次，用于完成类的一些初始化操作 </p><p><strong>实例代码块{}</strong></p><p>特点：每次创建对象时执行，在构造器前执行，用于完成类的一些初始化操作</p></li><li><p><strong>内部类</strong></p><p><strong>成员内部类</strong>：</p><p>创建对象的格式:外部类名.内部类名 对象名 = new 外部类(…).new 内部类(…);</p><p>成员内部类访问外部类成员的特点(拓展)：1、成员内部类中（的方法）可以直接访问外部类的静态成员（变量和方法），也可以访问类的实例成员  </p><p>2、成员内部类的实例方法中，可以直接拿到当前寄生的外部类对象： 外部类名.this</p><p><strong>静态内部类</strong>：</p><p>public static class 属于外部类本身所有 </p><p>外部类名.内部类名 对象名=new 外部类.内部类(..);</p><p>可以直接访问外部类的静态成员，不可以访问类的实例成员（实例成员属于外部类对象所有 ）</p><p><strong>局部内部类</strong>：</p><p>在方法、代码块、构造器等执行体中的内部类</p><p><strong>匿名内部类</strong>：</p><p>是一种特殊的局部内部类 不需要单独为它声明名字 本质是子类 会立即创建一个子类对象</p><blockquote><p> new 类或接口(){</p><p>​//类体（一般是重写）</p><p>};</p></blockquote></li><li><p><strong>函数式编程</strong>：</p><p><strong>lambda</strong></p><p>java中的函数就是lambda表达式</p><blockquote><p>(被重写方法的形参列表)-&gt;{</p><p>​被重写方法的方法体代码  </p><p>};</p></blockquote><p>lambda只能简化函数式接口（有且仅有一个抽象方法的接口 @FunctionalInterface）的匿名内部类</p><p>注意事项：</p><ol><li><p>参数类型全部可以省略不写。</p></li><li><p>如果只有一个参数，参数类型省略的同时“()”也可以省略，但多个参数不能省略“()”</p></li><li><p>如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号”;”如果这行代码是return语句，也必须去掉return。</p></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {<br>        Student[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">3</span>];<br>        s[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"Jerry"</span>,<span class="hljs-number">18</span>,<span class="hljs-string">'m'</span>);<br>        s[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"Tom"</span>,<span class="hljs-number">19</span>,<span class="hljs-string">'w'</span>);<br>        s[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">"Jack"</span>,<span class="hljs-number">20</span>,<span class="hljs-string">'m'</span>);<br><span class="hljs-comment">//        Arrays.sort(s, (Student o1,Student o2)-&gt;{</span><br><span class="hljs-comment">//            return o2.getAge()-o1.getAge();</span><br><span class="hljs-comment">//        });//按年龄降序</span><br>        Arrays.sort(s, (o1,o2)-&gt;o2.getAge()-o1.getAge());<span class="hljs-comment">//按年龄降序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) {<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> s[i];<br>            System.out.println(Arrays.toString(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[]{stu}));<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>方法引用</strong></p><p>用来简化lambda的</p><ol><li><p>静态方法引用</p><blockquote><p>类名::静态方法</p></blockquote><p>如果Lambda表达式只是调用一个静态方法，并且-&gt;前后的参数形式一致，则可以使用静态方法。</p></li><li><p>实例方法引用</p><blockquote><p>对象名:: 实例方法</p></blockquote><p>如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且-&gt;前后参数的形式一致，就可以使用实例方法引用。</p></li><li><p>特定类方法引用</p><blockquote><p>特定类名称::方法</p></blockquote><p>如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用。</p><p>例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(names,String::compareToIngoreCase);<br></code></pre></td></tr></tbody></table></figure></li><li><p>构造器引用</p><blockquote><p>类名::new</p></blockquote><p>如果某个Lambda表达式里只是在创建对象，并且-&gt;前后参数情况一致，就可以使用构造器引用。</p></li></ol></li><li><p><strong>常用API</strong></p><ol><li><p>字符串内容比较不用==（==会比较地址），字符串内容对比用.equals()</p></li><li><p>.charAt()获得对应位置的字符 </p></li><li><p>ArrayList集合：是一种容器，类似数组</p><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">ArrayList</span>&lt;<span class="hljs-built_in">String</span>&gt; list = <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></tbody></table></figure><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>add()</td><td>将元素插入到指定位置的 arraylist 中</td></tr><tr><td>addAll()</td><td>添加集合中的所有元素到 arraylist 中</td></tr><tr><td>clear()</td><td>删除 arraylist 中的所有元素</td></tr><tr><td>clone()</td><td>复制一份 arraylist</td></tr><tr><td>contains()</td><td>判断元素是否在 arraylist</td></tr><tr><td>get()</td><td>通过索引值获取 arraylist 中的元素</td></tr><tr><td>indexOf())</td><td>返回 arraylist 中元素的索引值</td></tr><tr><td>removeAll()</td><td>删除存在于指定集合中的 arraylist 里的所有元素</td></tr><tr><td>remove()</td><td>删除 arraylist 里的单个元素</td></tr><tr><td>size()</td><td>返回 arraylist 里元素数量</td></tr><tr><td>isEmpty()</td><td>判断 arraylist 是否为空</td></tr><tr><td>subList()</td><td>截取部分 arraylist 的元素</td></tr><tr><td>set()</td><td>替换 arraylist 中指定索引的元素</td></tr><tr><td>sort()</td><td>对 arraylist 元素进行排序</td></tr><tr><td>toArray()</td><td>将 arraylist 转换为数组</td></tr><tr><td>toString()</td><td>将 arraylist 转换为字符串</td></tr><tr><td>ensureCapacity</td><td>设置指定容量大小的 arraylist</td></tr><tr><td>lastIndexOf()</td><td>返回指定元素在 arraylist 中最后一次出现的位置</td></tr><tr><td>retainAll()</td><td>保留 arraylist 中在指定集合中也存在的那些元素</td></tr><tr><td>containsAll()</td><td>查看 arraylist 是否包含指定集合中的所有元素</td></tr><tr><td>trimToSize()</td><td>将 arraylist 中的容量调整为数组中的元素个数</td></tr><tr><td>removeRange()</td><td>删除 arraylist 中指定索引之间存在的元素</td></tr><tr><td>replaceAll()</td><td>将给定的操作内容替换掉数组中每一个元素</td></tr><tr><td>removeIf()</td><td>删除所有满足特定条件的 arraylist 元素</td></tr><tr><td>forEach()</td><td>遍历 arraylist 中每一个元素并执行特定操作</td></tr></tbody></table></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录一下244元组装的NAS</title>
    <link href="/2024/10/10/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B244%E5%85%83%E7%BB%84%E8%A3%85%E7%9A%84NAS/"/>
    <url>/2024/10/10/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B244%E5%85%83%E7%BB%84%E8%A3%85%E7%9A%84NAS/</url>
    
    <content type="html"><![CDATA[<p>NAS</p><span id="more"></span><p>自有备份照片的习惯已经十年了，从iPhone 3G的二百万像素到现在的千万像素，越来越多的照片和视频使得备份空间需求加剧。加上年初购置的一台256GB的电脑需要额外的存储空间，于是我开始研究外置存储设备。磨盘扩容、外置硬盘还是NAS？在分析了多台设备的存储占用后，我发现我的多数数据就是照片和视频，而且还有多设备多系统文件共享的需求，于是舍弃的读写速度选择NAS方案。</p><p>因为预算有限，故只能选择组装NAS。当开始研究NAS的时候，有几个关键的东西需要选择，第一个就是板U。按照我的需求，照片和视频的读写是最重要的，我的多数视频为h264编码，少量的iPhone拍摄的视频为h265。其次最后可以用上docker来配置一个homeassistant，当然这不是最重要的需求。多数的百元价位的板U采用了15、16年附近的J1900、J3160、N3160等处理器，他们的性能差距不大，都不能解码h265视频，但看在低廉的价格上，把h265视频down下来看也不成问题。经过一晚上在闲鱼里搜查，我找到了一个80元梅捷N3150的板子，带千兆板载网卡和两条ddr3 2GB内存，唯一的缺点是非ITX主板，尺寸为19x17cm，不过这样一来可以搭载更廉价的ATX机箱。机箱选取了空气盒子的小机箱，花费44元。电源也因此可以选择ATX电源。因为整机的峰值功率也就20w，所以我以21元的价格购置了一块400w的金河田二手电源。</p><p><img src="https://s3.bmp.ovh/imgs/2024/10/10/009e244b764b5032.jpg"></p><p>第二个需要选取的就是硬盘，前期经过对视频的压缩，我的备份大小已经减到了200GB，因此在短时间内可以使用一个500GB的空间来满足备份需求。西数蓝盘的500GB因为市场存量过大，随便一家网店都可以以低于20元的价格买到一块二手盘，我选择了两块500GB蓝盘组raid1来保证数据安全，共花费49元。其次需要一块盘来安装系统，我在多多随便购买了一块60GB的SATA固体盘，花费22元。因为主盘仅有两个SATA接口，故在闲鱼购买一个PCIE转SATA的扩展卡，花费18元。</p><p><img src="https://s3.bmp.ovh/imgs/2024/10/10/287461e36c51cd68.jpg"></p><p>最后需要选取的便是系统。在组装NAS的领域，最常见的系统便是黑群晖。但前些时日，某国产厂商推出了基于debian的NAS系统——飞牛OS。这个系统是还在测试阶段，功能自然没有群晖全，但足以满足我的全部需求。而且永久免费安装还有免费的穿透功能，我果断选择尝鲜飞牛OS。</p><p><img src="https://s3.bmp.ovh/imgs/2024/10/10/20896d6675db2ba8.png"></p><p>上述花费共244元，因为电源风扇的噪声约为40db，放在桌下在极安静的场景下可以听到明显的噪音，于是购买了10米的网线将其安置在了房间的进门处。</p><blockquote><p>板U 80</p><p>机箱 44</p><p>电源 21.3</p><p>HDD 49.3</p><p>转接卡 18</p><p>SATA固态 22.2</p><p>电源线 3.53</p><p>网线 5.6</p></blockquote><p>自组装完成到现在已使用两周了，在常用的几个场景中，这套NAS表现的非常好。</p><p><img src="https://s3.bmp.ovh/imgs/2024/10/10/4b181c985aa9faa8.png"></p><p>首先是相册备份。在App store中可以下载到飞牛官方的app“飞牛私有云”。配合iOS的快捷指令，程序会在我设定的时间启动并自动备份，几乎做到了和iCloud一样的无感体验。在手机app中，h264的视频可以流畅的外网访问，h265视频无法播放。</p><div style="text-align: center;">    <img src="https://s3.bmp.ovh/imgs/2024/10/10/70aee39415b6c9bd.jpg" style="zoom:25%;"></div><p>第二个场景便是在电脑上的备份，使用“访达”连接到NAS后，NAS可被视作本地存储，每次修好的图片直接输出到NAS中，在写入和读取速度上几乎察觉不带延迟。</p><p>第三个场景是homeassistant。飞牛OS中已经配置好了docker，可以直接配置homeassistant并接入米家设备。然后使用bridge接入苹果的“家庭”，在内网环境下可以实现无延迟的操控。当然在宿舍环境下，这就是图一乐的功能。</p><p><img src="https://s3.bmp.ovh/imgs/2024/10/10/13bc9a7fd9ed6aa7.png"></p><p>其实NAS最重要的是稳定性，这一点还有待观察。持续使用中，待后续更新。</p>]]></content>
    
    
    <categories>
      
      <category>玩机</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24年9月28日记</title>
    <link href="/2024/09/28/24%E5%B9%B49%E6%9C%8828%E6%97%A5%E8%AE%B0/"/>
    <url>/2024/09/28/24%E5%B9%B49%E6%9C%8828%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>系统已填报，如履薄冰</p><span id="more"></span><p>推免系统已于今天上午开始报名，我填报了一个私认为是”最优选“的学校，释放了手上其他的Offer，开始了焦灼的候补阶段。</p><p>五月份，刚刚联系了一位”饮水思源“学校的”梦导“，心中筹划了一套”完美“的推免路线。逢小长假，课程不多于是回了一趟家乡。李叔恰好也在家乡，他是我从小就特别仰慕的一位实干家。饭桌上，李叔问我未来的规划，我便讲了讲。其实这个时候我对自己的定位还是模糊的，太多假大空的东西停留在设想中，说起自己的规划也是有一些踌躇。李叔先是给我讲了他近几年的奋斗史（我一直特别好奇，多年的好奇心总是得到了满足），鼓励我如履薄冰的一往无前。几个月来我也一直没有忘记，但今日的我似乎真的在如履薄冰的一往无前了。</p><p>推免的路到现在其实一直走的不顺，夏令营被梦校拒，但却意外的入了两个我从未敢想的学校。日复一日地完成工作，第一次切实地感受到”头晕脑胀，两眼昏花“，到头来被要求报了其他院地预推免（日行千里，四天三夜睡了十小时却被赶出了面试。那天，走出面试的教学楼正逢下课，学生们骑车穿行在校园的林荫大道上，嬉笑声，车铃声，嘈杂交织，这样的画面是我自初中以来便畅想的校园生活，可那时的我像丧家之犬一样与周围的一切格格不入。）到头来，报个本校吧，这里有我喜欢的老师，有感兴趣的方向，是”崇洋媚外“亦或是我确实太弱了，哈哈，本校也不要我。</p><p>我不擅长骗人，我喜欢做一个正直诚实的好人。果断地释放名额希望别人能有学上，希望能少一个同学像我一样还在担忧着。</p><p>起风吧，祝自己如愿以偿。</p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分享一些我在SDU的学习资料</title>
    <link href="/2024/09/06/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E6%88%91%E5%9C%A8SDU%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <url>/2024/09/06/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E6%88%91%E5%9C%A8SDU%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<p>欢迎抓虫！持续更新^_^</p><span id="more"></span><p>已经大四的我没修完限选课程，故在大四的上学期还是需要每周去一趟振声院上课。</p><p>第一节课上授课老师反复的将钱挂在嘴边，也是有一点点小小的震撼，难道有钱就拥有了一切吗？（有可能，等有钱了才能知道）</p><p>分享一些我在SDU CST学院的学习笔记，绝大多数内容是我手写的，部分取自课件和学长学姐的笔记。自认为笔记的字写的还是挺好看的，或许也可以在网易群里出售一下，没必要，但凡对后来者有些帮助的事情我都是乐意去分享的。</p><p><strong>高等数学</strong></p><p><a href="https://github.com/BIGGGJerry/Course_In_SDUCST/blob/main/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/Note%E9%83%A8%E5%88%86.pdf">部分笔记（由于更换设备丢失了一些）</a></p><p><strong>离散数学</strong></p><p><a href="https://github.com/BIGGGJerry/Course_In_SDUCST/blob/main/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/Discrete%20Math%E9%83%A8%E5%88%86.pdf">Discrete Math部分</a></p><p><strong>概率论与数理统计</strong></p><p><a href="https://github.com/BIGGGJerry/Course_In_SDUCST/blob/main/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0.pdf">复习笔记</a></p><p><strong>公钥密码学的数学基础</strong></p><p><a href="https://github.com/BIGGGJerry/Course_In_SDUCST/blob/main/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/Note_chapter1-3.pdf">1-3章笔记</a></p><p><a href="https://github.com/BIGGGJerry/Course_In_SDUCST/blob/main/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/Note_chapter8-19.pdf">8-19章笔记</a></p><p><strong>软件安全</strong>（我最喜欢的课程）</p><p><a href="https://github.com/BIGGGJerry/Course_In_SDUCST/blob/main/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Note.pdf">软件安全笔记</a></p><p><strong>计算机组成与设计</strong></p><p><a href="https://github.com/BIGGGJerry/Course_In_SDUCST/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1_%E7%AD%94%E6%A1%88%E6%89%8B%E5%86%8C%EF%BC%88RISC_V%EF%BC%89_230215_232824.pdf">RISC-V版课本习题答案</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
